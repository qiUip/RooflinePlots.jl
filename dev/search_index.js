var documenterSearchIndex = {"docs":
[{"location":"examples/custom_combined_groups/","page":"-","title":"-","text":"Metric Value\nMeasured FP32 Compute 3500.0 GFLOP/s\nPercentage of Peak FP32 87.5%\nMeasured INT8+INT16 Compute 7200.0 GFLOP/s\nPercentage of Peak INT8 60.0%\nPercentage of Peak INT16 90.0%\nMeasured DDR5 Bandwidth 350.00 GB/s\nPercentage of Peak DDR5 BW 87.5%\nFP32/DDR5 AI 10.00 FLOP/B\nINT8+INT16/DDR5 AI 20.57 FLOP/B\nBottleneck Memory-bound (INT8/DDR5)","category":"section"},{"location":"examples/custom_hbm_tensor/","page":"-","title":"-","text":"Metric Value\nMeasured FP32 Compute 2100.0 GFLOP/s\nPercentage of Peak FP32 84.0%\nMeasured TENSOR Compute 4200.0 GFLOP/s\nPercentage of Peak TENSOR 84.0%\nMeasured L2 Bandwidth 2800.00 GB/s\nPercentage of Peak L2 BW 87.5%\nMeasured HBM Bandwidth 950.00 GB/s\nPercentage of Peak HBM BW 79.2%\nFP32/HBM AI 2.21 FLOP/B\nTENSOR/HBM AI 4.42 FLOP/B\nFP32/L2 AI 0.75 FLOP/B\nTENSOR/L2 AI 1.50 FLOP/B\nBottleneck Memory-bound (FP32+TENSOR/L2)","category":"section"},{"location":"examples/full_hierarchy/","page":"-","title":"-","text":"Metric Value\nMeasured DP Compute 720.0 GFLOP/s\nPercentage of Peak DP 51.2%\nMeasured L1 Bandwidth 890.00 GB/s\nPercentage of Peak L1 BW 27.8%\nMeasured L2 Bandwidth 185.00 GB/s\nPercentage of Peak L2 BW 14.1%\nMeasured L3 Bandwidth 125.00 GB/s\nPercentage of Peak L3 BW 26.0%\nMeasured DRAM Bandwidth 21.89 GB/s\nPercentage of Peak DRAM BW 22.7%\nDP/DRAM AI 32.89 FLOP/B\nDP/L1 AI 0.81 FLOP/B\nDP/L2 AI 3.89 FLOP/B\nDP/L3 AI 5.76 FLOP/B\nBottleneck Compute-bound","category":"section"},{"location":"examples/combined_dp_sp/","page":"-","title":"-","text":"Metric Value\nMeasured DP+SP Compute 720.0 GFLOP/s\nPercentage of Peak DP 51.2%\nPercentage of Peak SP 25.6%\nMeasured L2 Bandwidth 185.00 GB/s\nPercentage of Peak L2 BW 14.1%\nMeasured DRAM Bandwidth 21.89 GB/s\nPercentage of Peak DRAM BW 22.7%\nDP+SP/DRAM AI 32.89 FLOP/B\nDP+SP/L2 AI 3.89 FLOP/B\nBottleneck Compute-bound","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete API documentation for RooflinePlots.jl.","category":"section"},{"location":"api/#Module","page":"API Reference","title":"Module","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Configuration-Functions","page":"API Reference","title":"Configuration Functions","text":"","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#Analysis-Functions","page":"API Reference","title":"Analysis Functions","text":"","category":"section"},{"location":"api/#Plotting-Functions","page":"API Reference","title":"Plotting Functions","text":"","category":"section"},{"location":"api/#Reporting-Functions","page":"API Reference","title":"Reporting Functions","text":"","category":"section"},{"location":"api/#CLI-Functions","page":"API Reference","title":"CLI Functions","text":"","category":"section"},{"location":"api/#RooflinePlots","page":"API Reference","title":"RooflinePlots","text":"RooflinePlots\n\nA Julia package for generating Roofline Model visualizations and performance analysis.\n\nThe Roofline Model visualizes performance limits based on computational throughput (FLOP/s) and memory bandwidth (GB/s), identifying whether applications are compute-bound or memory-bound.\n\nMain Types\n\nRooflineParams: User-facing parameter specification\nOutputOptions: Visualization and output options\nRooflineConfig: Internal configuration (created by params_to_config)\nComputeRoof, MemoryLevel, Measurement: Core data structures\n\nMain Functions\n\ncreate_roofline_plot: Create Roofline plots\nprint_performance_table: Display performance metrics\ndetermine_bottleneck: Identify performance bottleneck\nparams_to_config: Convert parameters to configuration\n\n\n\n\n\n","category":"module"},{"location":"api/#RooflinePlots.ComputeRoof","page":"API Reference","title":"RooflinePlots.ComputeRoof","text":"ComputeRoof\n\nRepresents a compute performance ceiling in the Roofline Model.\n\nFields\n\nname::String: Compute type identifier (e.g., \"DP\", \"SP\", \"DP_AVX\")\npeak_flops::Float64: Peak performance in GFLOP/s\ncolor::Union{Symbol,String}: Color for plotting (Symbol for color names, String for hex)\n\n\n\n\n\n","category":"type"},{"location":"api/#RooflinePlots.MemoryLevel","page":"API Reference","title":"RooflinePlots.MemoryLevel","text":"MemoryLevel\n\nRepresents a memory hierarchy level with its peak bandwidth.\n\nFields\n\nname::String: Memory level identifier (e.g., \"DRAM\", \"L3\", \"L2\", \"L1\")\npeak_bw::Float64: Peak bandwidth in GB/s\ncolor::Union{Symbol,String}: Color for plotting (Symbol for color names, String for hex)\n\n\n\n\n\n","category":"type"},{"location":"api/#RooflinePlots.Measurement","page":"API Reference","title":"RooflinePlots.Measurement","text":"Measurement\n\nA single performance measurement point on the Roofline plot.\n\nFields\n\ncompute_name::String: Compute type (e.g., \"DP\", \"SP\")\nmemory_name::String: Memory level (e.g., \"DRAM\", \"L3\")\nflops::Float64: Measured performance in GFLOP/s\nbandwidth::Float64: Measured bandwidth in GB/s\n\n\n\n\n\n","category":"type"},{"location":"api/#RooflinePlots.RooflineConfig","page":"API Reference","title":"RooflinePlots.RooflineConfig","text":"RooflineConfig\n\nInternal configuration for Roofline plot generation.\n\nCreated by params_to_config() from RooflineParams and OutputOptions. Contains processed roofs, memory levels, measurements, and display settings.\n\nUsers should work with RooflineParams and OutputOptions instead of constructing this directly.\n\n\n\n\n\n","category":"type"},{"location":"api/#RooflinePlots.RooflineParams","page":"API Reference","title":"RooflinePlots.RooflineParams","text":"RooflineParams\n\nUser-facing parameter specification for Roofline analysis.\n\nSupports arbitrary memory types (DRAM, L3, HBM, etc.) and compute types (DP, SP, TENSOR, etc.). Each type requires a peak value and optionally a measured value.\n\nCombined measurements allow a single measured value to apply to multiple compute types.\n\nFields\n\nmemory_specs: Dict mapping memory type names to (peak, measured) bandwidth in GB/s\ncompute_specs: Dict mapping compute type names to (peak, measured) FLOPS in GFLOP/s\ncombined_flops: Single measured value applying to all compute types (optional)\ncombined_flops_groups: List of (types, measured) for specific combined groups (optional)\nnum_cores, topology, cpu_name, app_name: Metadata for plot title and filenames\n\n\n\n\n\n","category":"type"},{"location":"api/#RooflinePlots.OutputOptions","page":"API Reference","title":"RooflinePlots.OutputOptions","text":"OutputOptions\n\nVisualization and output formatting options for Roofline plots and tables.\n\nFields\n\nforce_simple: Force linear scale plotting instead of log-log (default: false)\ntable_format: Table format: \"ascii\", \"org\", \"markdown\", or \"csv\" (default: \"ascii\")\nmem_colors: Custom color palette for memory levels (optional)\ncompute_colors: Custom color palette for compute types (optional)\nplot_format: Plot file format: \"png\", \"pdf\", or \"svg\" (default: \"png\")\n\nUse keyword constructor to override defaults:\n\nOutputOptions(plot_format=\"pdf\", table_format=\"markdown\")\n\n\n\n\n\n","category":"type"},{"location":"api/#RooflinePlots.params_to_config","page":"API Reference","title":"RooflinePlots.params_to_config","text":"params_to_config(params::RooflineParams, output_opts::OutputOptions=OutputOptions()) -> RooflineConfig\n\nConvert user parameters to internal configuration for plotting and reporting.\n\nProcesses memory/compute specs, creates measurements, assigns colors, and determines display mode (simple vs hierarchical). Fully generic - supports any type names.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.get_measured_flops","page":"API Reference","title":"RooflinePlots.get_measured_flops","text":"get_measured_flops(params::RooflineParams, compute_name::String) -> Union{Float64, Nothing}\n\nRetrieve measured FLOPS value for a compute type (checks individual, combined, and group measurements).\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.assign_colors!","page":"API Reference","title":"RooflinePlots.assign_colors!","text":"assign_colors!(items::Vector{T}, user_colors, default_palette, constructor)\n\nAssign colors to items from user palette or default palette, reconstructing items with assigned colors.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.generate_output_filename","page":"API Reference","title":"RooflinePlots.generate_output_filename","text":"generate_output_filename(params::RooflineParams, hierarchical::Bool, format::String=\"png\") -> String\n\nGenerate output filename based on CPU, topology, plot type, and format.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.MEMORY_COLORS","page":"API Reference","title":"RooflinePlots.MEMORY_COLORS","text":"Default color palettes for memory levels (cool tones) and compute types (warm tones).\n\n\n\n\n\n","category":"constant"},{"location":"api/#RooflinePlots.parse_color","page":"API Reference","title":"RooflinePlots.parse_color","text":"parse_color(color_str::AbstractString) -> Union{Symbol, String}\n\nParse a color string. Supports color names (\"red\", \"blue\") and hex colors (\"#FF5733\").\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.parse_color_palette","page":"API Reference","title":"RooflinePlots.parse_color_palette","text":"parse_color_palette(palette_str::AbstractString) -> Vector{Union{Symbol, String}}\n\nParse a comma-separated color palette string (e.g., \"red,blue,#FF5733\").\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.find_combined_group","page":"API Reference","title":"RooflinePlots.find_combined_group","text":"find_combined_group(config::RooflineConfig, type_name::String) -> Union{Vector{String}, Nothing}\n\nFind the combined compute group containing the given type name. Returns the group or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.are_in_same_group","page":"API Reference","title":"RooflinePlots.are_in_same_group","text":"are_in_same_group(config::RooflineConfig, type1::String, type2::String) -> Bool\n\nCheck if two compute types are in the same combined group.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.calculate_arithmetic_intensity","page":"API Reference","title":"RooflinePlots.calculate_arithmetic_intensity","text":"calculate_arithmetic_intensity(measurement::Measurement) -> Float64\n\nCalculate arithmetic intensity (FLOP/Byte) as flops / bandwidth.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.find_memory_level","page":"API Reference","title":"RooflinePlots.find_memory_level","text":"find_memory_level(config::RooflineConfig, name::String) -> Union{MemoryLevel, Nothing}\n\nFind memory level by name. Returns the MemoryLevel or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.find_compute_roof","page":"API Reference","title":"RooflinePlots.find_compute_roof","text":"find_compute_roof(config::RooflineConfig, name::String) -> Union{ComputeRoof, Nothing}\n\nFind compute roof by name. Returns the ComputeRoof or nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.determine_bottleneck","page":"API Reference","title":"RooflinePlots.determine_bottleneck","text":"determine_bottleneck(config::RooflineConfig) -> String\n\nIdentify primary performance bottleneck by comparing arithmetic intensity against ridge points.\n\nReturns the highest-priority bottleneck: memory-bound (by level and type) or compute-bound. Handles combined measurements and flexible memory hierarchies.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.create_roofline_plot","page":"API Reference","title":"RooflinePlots.create_roofline_plot","text":"create_roofline_plot(config::RooflineConfig; show_ridges::Bool=true) -> Plots.Plot\n\nCreate a complete Roofline plot from configuration (linear or log-log based on config.simple_mode).\n\n\n\n\n\ncreate_roofline_plot(params::RooflineParams, output_opts::OutputOptions=OutputOptions(); show_ridges::Bool=true) -> Plots.Plot\n\nCreate a Roofline plot directly from user parameters (convenience wrapper).\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.plot_roofline!","page":"API Reference","title":"RooflinePlots.plot_roofline!","text":"plot_roofline!(plt, config::RooflineConfig; show_ridges::Bool=true)\n\nAdd Roofline elements (roofs, memory lines, ridges, measurements, labels) to an existing plot.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.print_performance_table","page":"API Reference","title":"RooflinePlots.print_performance_table","text":"print_performance_table(config::RooflineConfig)\n\nPrint a formatted table of performance metrics and bottleneck analysis.\n\nShows measured vs peak performance for compute types and memory levels, arithmetic intensity, and bottleneck. Supports multiple table formats (ascii, org, markdown, csv). Handles combined measurements.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.run_cli","page":"API Reference","title":"RooflinePlots.run_cli","text":"run_cli()\n\nMain CLI orchestration function. Parses command-line arguments, generates performance tables and plots, and saves output files.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.parse_commandline","page":"API Reference","title":"RooflinePlots.parse_commandline","text":"parse_commandline() -> Dict\n\nParse command-line arguments with generic type names.\n\nReturns a dictionary with:\n\n\"memory_specs\": Dict{String, @NamedTuple{peak::Union{Float64,Nothing}, measured::Union{Float64,Nothing}}}\n\"compute_specs\": Dict{String, @NamedTuple{peak::Union{Float64,Nothing}, measured::Union{Float64,Nothing}}}\n\"combined_flops\": Union{Float64,Nothing} (from –measured-flops without suffix)\n\"combinedflopsgroups\": Vector{Tuple{Vector{String}, Float64}} (from –measured-flops-type1-type2)\nStandard metadata fields\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.get_table_file_extension","page":"API Reference","title":"RooflinePlots.get_table_file_extension","text":"get_table_file_extension(table_format::AbstractString) -> String\n\nGet file extension for the given table format.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.validate_positive","page":"API Reference","title":"RooflinePlots.validate_positive","text":"validate_positive(value::Real, arg_name::String)\n\nValidate that a numeric argument is positive (> 0). Throws ArgumentError if validation fails.\n\n\n\n\n\n","category":"function"},{"location":"api/#RooflinePlots.print_help","page":"API Reference","title":"RooflinePlots.print_help","text":"print_help()\n\nPrint help message for CLI.\n\n\n\n\n\n","category":"function"},{"location":"testing/#Testing-Guide","page":"Testing","title":"Testing Guide","text":"","category":"section"},{"location":"testing/#Running-Tests","page":"Testing","title":"Running Tests","text":"","category":"section"},{"location":"testing/#Complete-Test-Suite","page":"Testing","title":"Complete Test Suite","text":"julia --project=. -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"testing/#Unit-Tests","page":"Testing","title":"Unit Tests","text":"Run all unit tests:\n\njulia --project=. test/run_unit_tests.jl\n\nRun specific modules:\n\njulia --project=. test/run_unit_tests.jl types      # Type constructors\njulia --project=. test/run_unit_tests.jl config     # Configuration\njulia --project=. test/run_unit_tests.jl analysis   # Bottleneck detection\njulia --project=. test/run_unit_tests.jl reporting  # Performance tables\njulia --project=. test/run_unit_tests.jl cli        # CLI parsing\njulia --project=. test/run_unit_tests.jl plotting   # Plot generation","category":"section"},{"location":"testing/#Integration-Tests","page":"Testing","title":"Integration Tests","text":"julia --project=. test/run_integration_tests.jl","category":"section"},{"location":"testing/#Python-Interface-Tests","page":"Testing","title":"Python Interface Tests","text":"python test/test_python_interface.py\n\nRequires: pip install juliacall","category":"section"},{"location":"testing/#Cleanup","page":"Testing","title":"Cleanup","text":"julia --project=. test/run_unit_tests.jl clean\njulia --project=. test/run_integration_tests.jl clean","category":"section"},{"location":"testing/#Test-Organization","page":"Testing","title":"Test Organization","text":"test/\n├── runtests.jl                  # Main test runner (Pkg.test())\n├── run_unit_tests.jl            # Unit test runner\n├── run_integration_tests.jl     # Integration test runner\n├── test_types.jl                # Type constructors\n├── test_config.jl               # Configuration conversion\n├── test_analysis.jl             # Bottleneck detection\n├── test_reporting.jl            # Performance tables\n├── test_cli.jl                  # CLI argument parsing\n├── test_plotting.jl             # Plot generation\n├── test_table_formats.jl        # Table output formats\n├── test_integration.jl          # End-to-end workflows\n├── test_python_interface.py     # Python interface\n└── examples/                    # Generated examples","category":"section"},{"location":"testing/#Test-Coverage","page":"Testing","title":"Test Coverage","text":"Unit Tests - Individual functions and modules:\n\nType constructors and validation\nConfiguration conversion\nBottleneck detection\nPerformance table formatting\nCLI argument parsing\nPlot generation\n\nIntegration Tests - End-to-end workflows:\n\nSimple DRAM+DP configuration\nHierarchical memory (L1/L2/L3/DRAM)\nMultiple compute types\nCombined measurements\nCustom colors\nTable output formats\n\nPython Tests - Python interface via JuliaCall:\n\nRooflinePlotter utility class\nAll major use cases\nPlot generation from Python","category":"section"},{"location":"testing/#Example-Outputs","page":"Testing","title":"Example Outputs","text":"Integration tests generate plots and tables in test/examples/ (see Examples for reference):\n\nls test/examples/\n# *.svg - Roofline plots\n# *.md - Table outputs\n\nSee test/examples/README.md for descriptions.","category":"section"},{"location":"examples/hierarchical_l2_dram_dp_sp/","page":"-","title":"-","text":"Metric Value\nMeasured DP Compute 720.0 GFLOP/s\nPercentage of Peak DP 51.2%\nMeasured SP Compute 1440.0 GFLOP/s\nPercentage of Peak SP 51.3%\nMeasured L2 Bandwidth 185.00 GB/s\nPercentage of Peak L2 BW 14.1%\nMeasured DRAM Bandwidth 21.89 GB/s\nPercentage of Peak DRAM BW 22.7%\nDP/DRAM AI 32.89 FLOP/B\nSP/DRAM AI 65.78 FLOP/B\nDP/L2 AI 3.89 FLOP/B\nSP/L2 AI 7.78 FLOP/B\nBottleneck Compute-bound","category":"section"},{"location":"usage/#User-Guide","page":"User Guide","title":"User Guide","text":"This guide shows how to use RooflinePlots.jl to create roofline plots and analyze performance.","category":"section"},{"location":"usage/#Command-Line-Usage","page":"User Guide","title":"Command Line Usage","text":"The simplest way to use RooflinePlots.jl is via the command line interface.  ","category":"section"},{"location":"usage/#Basic-Example","page":"User Guide","title":"Basic Example","text":"./roofline.jl \\\n    --peak-bw-DRAM=204.8 \\\n    --measured-bw-DRAM=180.5 \\\n    --peak-flops-DP=2150.4 \\\n    --measured-flops-DP=1245.2 \\\n    --cpu-name=\"AMD EPYC 7713\" \\\n    --app-name=\"My Application\"","category":"section"},{"location":"usage/#Multi-Level-Memory-Hierarchy","page":"User Guide","title":"Multi-Level Memory Hierarchy","text":"./roofline.jl \\\n    --peak-bw-DRAM=96.42 \\\n    --measured-bw-DRAM=21.89 \\\n    --peak-bw-L3=480.0 \\\n    --measured-bw-L3=125.0 \\\n    --peak-bw-L2=1312.0 \\\n    --measured-bw-L2=185.0 \\\n    --peak-bw-L1=3200.0 \\\n    --measured-bw-L1=890.0 \\\n    --peak-flops-DP=1404.9 \\\n    --measured-flops-DP=720.0 \\\n    --num-cores=24 \\\n    --topology=\"Single NUMA\" \\\n    --cpu-name=\"Genoa @1.9GHz\" \\\n    --app-name=\"Full Hierarchy\"","category":"section"},{"location":"usage/#Multiple-Compute-Types","page":"User Guide","title":"Multiple Compute Types","text":"./roofline.jl \\\n    --peak-bw-DRAM=102.4 \\\n    --measured-bw-DRAM=78.3 \\\n    --peak-flops-DP=1200.0 \\\n    --measured-flops-DP=650.0 \\\n    --peak-flops-SP=2400.0 \\\n    --measured-flops-SP=1280.0 \\\n    --peak-flops-DP_AVX=1920.0 \\\n    --measured-flops-DP_AVX=1050.0 \\\n    --peak-flops-SP_AVX=3840.0 \\\n    --measured-flops-SP_AVX=2100.0 \\\n    --num-cores=16 \\\n    --topology=\"Single Socket\" \\\n    --cpu-name=\"AMD EPYC\" \\\n    --app-name=\"Matrix Multiply\"","category":"section"},{"location":"usage/#Combined-Measurements","page":"User Guide","title":"Combined Measurements","text":"When hardware counters measure multiple compute types together:\n\n# Specific types combined\n./roofline.jl \\\n    --peak-bw-HBM=1200.0 \\\n    --measured-bw-HBM=980.0 \\\n    --peak-flops-FP32=19500.0 \\\n    --peak-flops-TENSOR=156000.0 \\\n    --measured-flops-FP32-TENSOR=145000.0 \\\n    --num-cores=80 \\\n    --topology=\"GPU\" \\\n    --cpu-name=\"NVIDIA A100\" \\\n    --app-name=\"Deep Learning\"\n\n# All types combined\n./roofline.jl \\\n    --peak-bw-DRAM=102.4 \\\n    --measured-bw-DRAM=78.3 \\\n    --peak-flops-DP=1200.0 \\\n    --peak-flops-SP=2400.0 \\\n    --measured-flops=1850.0 \\\n    --num-cores=16 \\\n    --topology=\"Dual Socket\" \\\n    --cpu-name=\"Intel Xeon\" \\\n    --app-name=\"Mixed Precision\"","category":"section"},{"location":"usage/#Custom-Colors","page":"User Guide","title":"Custom Colors","text":"./roofline.jl \\\n    --peak-bw-DRAM=204.8 \\\n    --measured-bw-DRAM=180.5 \\\n    --peak-bw-L3=1200.0 \\\n    --measured-bw-L3=950.0 \\\n    --peak-flops-DP=2150.4 \\\n    --measured-flops-DP=1245.2 \\\n    --peak-flops-SP=4300.0 \\\n    --measured-flops-SP=2500.0 \\\n    --mem-colors=\"#3498DB,#2ECC71\" \\\n    --compute-colors=\"orange,purple\"","category":"section"},{"location":"usage/#Output-Options","page":"User Guide","title":"Output Options","text":"./roofline.jl \\\n    --peak-bw-DRAM=204.8 \\\n    --measured-bw-DRAM=180.5 \\\n    --peak-flops-DP=2150.4 \\\n    --measured-flops-DP=1245.2 \\\n    --output=my_plot.png \\\n    --table-format=markdown \\\n    --save-table \\\n    --quiet \\\n    --hide-ridges \\\n    --force-simple","category":"section"},{"location":"usage/#Command-Line-Options","page":"User Guide","title":"Command Line Options","text":"RooflinePlots.jl offers a flexible approach for defining arbitrary memory and compute types with the following command line options, meta-data to use for the plot labelling, and several output options to produce rooflines in a customised style.","category":"section"},{"location":"usage/#Memory-and-Compute-Specifications","page":"User Guide","title":"Memory and Compute Specifications","text":"Memory bandwidth (at least one required):\n\n--peak-bw-<TYPE>=<value> - Peak bandwidth in GB/s\n--measured-bw-<TYPE>=<value> - Measured bandwidth in GB/s\n\nExamples: --peak-bw-DRAM=204.8, --peak-bw-HBM=1200.0, --peak-bw-L3=480.0\n\nCompute performance (at least one required):\n\n--peak-flops-<TYPE>=<value> - Peak performance in GFLOP/s\n--measured-flops-<TYPE>=<value> - Measured performance in GFLOP/s\n\nExamples: --peak-flops-DP=2150.4, --peak-flops-TENSOR=156000.0\n\nCombined measurements:\n\n--measured-flops=<value> - All compute types combined\n--measured-flops-<TYPE1>-<TYPE2>=<value> - Specific types combined\n\nExamples: --measured-flops=720.0, --measured-flops-DP-SP=720.0\n\nRequirements:\n\nEach memory type needs both peak and measured values\nEach compute peak needs either an individual measurement or inclusion in a combined measurement\n\nType naming: Avoid hyphens in type names (use underscores instead: DP_AVX, FP32_TENSOR)","category":"section"},{"location":"usage/#Metadata","page":"User Guide","title":"Metadata","text":"--num-cores=<N> - Number of cores (default: omitted from filename)\n--topology=<string> - Topology description (default: \"Topology\")\n--cpu-name=<string> - CPU/GPU model name (default: \"CPU\")\n--app-name=<string> - Application name (default: \"Application\")","category":"section"},{"location":"usage/#Output-Control","page":"User Guide","title":"Output Control","text":"--output=<file>, -o <file> - Output filename (auto-generated if not specified)\n--quiet, -q - Suppress table output\n--show, -s - Display plot window\n--hide-ridges - Hide ridge point lines\n--force-simple - Force linear scaling\n--table-format=<fmt> - Table format: ascii, org, markdown, or csv\n--save-table - Save table to file with appropriate extension\n--plot-format=<fmt> - Plot format: png, pdf, or svg (default: png)","category":"section"},{"location":"usage/#Colors","page":"User Guide","title":"Colors","text":"--mem-colors=<colors> - Memory colors (comma-separated)\n--compute-colors=<colors> - Compute colors (comma-separated)\n\nSupported formats: color names (red, blue, orange) or hex codes (#FF5733, #3498DB)\n\nAll Julia named colors are supported","category":"section"},{"location":"usage/#Julia-API","page":"User Guide","title":"Julia API","text":"As well as the command line options, RooflinePlots.jl can be used as a library with simple API for direct integration within other Julia programs.","category":"section"},{"location":"usage/#Basic-Example-2","page":"User Guide","title":"Basic Example","text":"using RooflinePlots\n\nmemory_specs = Dict(\"DRAM\" => (peak=204.8, measured=180.5))\ncompute_specs = Dict(\"DP\" => (peak=2150.4, measured=1245.2))\n\nparams = RooflineParams(\n    memory_specs,\n    compute_specs,\n    nothing,  # combined_flops\n    [],       # combined_flops_groups\n    64,       # num_cores\n    \"Dual Socket\",\n    \"AMD EPYC 7713\",\n    \"My Application\"\n)\n\nconfig = params_to_config(params)\nplt = create_roofline_plot(config)\nsavefig(plt, \"roofline.png\")\nprint_performance_table(config)","category":"section"},{"location":"usage/#Hierarchical-Memory","page":"User Guide","title":"Hierarchical Memory","text":"memory_specs = Dict(\n    \"DRAM\" => (peak=96.42, measured=21.89),\n    \"L3\"   => (peak=480.0, measured=125.0),\n    \"L2\"   => (peak=1312.0, measured=185.0),\n    \"L1\"   => (peak=3200.0, measured=890.0)\n)\n\ncompute_specs = Dict(\"DP\" => (peak=1404.9, measured=720.0))\n\nparams = RooflineParams(\n    memory_specs, compute_specs, nothing, [],\n    24, \"Single NUMA\", \"Genoa @1.9GHz\", \"TestApp\"\n)\n\nconfig = params_to_config(params)\nplt = create_roofline_plot(config)\nsavefig(plt, \"hierarchical.png\")","category":"section"},{"location":"usage/#Multiple-Compute-Types-2","page":"User Guide","title":"Multiple Compute Types","text":"memory_specs = Dict(\"DRAM\" => (peak=102.4, measured=78.3))\n\ncompute_specs = Dict(\n    \"DP\"     => (peak=1200.0, measured=650.0),\n    \"SP\"     => (peak=2400.0, measured=1280.0),\n    \"DP_AVX\" => (peak=1920.0, measured=1050.0),\n    \"SP_AVX\" => (peak=3840.0, measured=2100.0)\n)\n\nparams = RooflineParams(\n    memory_specs, compute_specs, nothing, [],\n    16, \"Single Socket\", \"AMD EPYC\", \"Matrix Multiply\"\n)","category":"section"},{"location":"usage/#Combined-Measurements-2","page":"User Guide","title":"Combined Measurements","text":"memory_specs = Dict(\"HBM\" => (peak=1200.0, measured=980.0))\n\n# Peak performance without individual measurements\ncompute_specs = Dict(\n    \"FP32\"   => (peak=19500.0, measured=nothing),\n    \"TENSOR\" => (peak=156000.0, measured=nothing)\n)\n\n# Hardware counter measured both together\ncombined_groups = [\n    ([\"FP32\", \"TENSOR\"], 145000.0)\n]\n\nparams = RooflineParams(\n    memory_specs, compute_specs, nothing, combined_groups,\n    80, \"GPU\", \"NVIDIA A100\", \"Deep Learning\"\n)","category":"section"},{"location":"usage/#Custom-Colors-2","page":"User Guide","title":"Custom Colors","text":"memory_specs = Dict(\n    \"DRAM\" => (peak=204.8, measured=180.5),\n    \"L3\"   => (peak=1200.0, measured=950.0)\n)\n\ncompute_specs = Dict(\n    \"DP\" => (peak=2150.4, measured=1245.2),\n    \"SP\" => (peak=4300.0, measured=2500.0)\n)\n\nparams = RooflineParams(\n    memory_specs, compute_specs, nothing, [],\n    64, \"Dual Socket\", \"AMD EPYC 7713\", \"My Application\"\n)\n\noutput_opts = OutputOptions(\n    mem_colors = [:cyan, :magenta],\n    compute_colors = [:orange, \"#FF5733\"]\n)\n\nconfig = params_to_config(params, output_opts)\nplt = create_roofline_plot(config)\nsavefig(plt, \"custom_colors.png\")","category":"section"},{"location":"usage/#Understanding-the-Output","page":"User Guide","title":"Understanding the Output","text":"","category":"section"},{"location":"usage/#Plot-Elements","page":"User Guide","title":"Plot Elements","text":"Diagonal lines: Memory bandwidth limits (slope = bandwidth)\nHorizontal lines: Compute performance ceilings\nRidge points: Intersections where bottleneck transitions\nMarkers: Measured performance points with circle fill color matching the memory level and stroke color matching the compute type (for multiple compute types)","category":"section"},{"location":"usage/#Performance-Table","page":"User Guide","title":"Performance Table","text":"Shows for each compute type:\n\nMeasured performance as percentage of peak\nArithmetic intensity (FLOP/Byte) for each memory level\nIdentified bottleneck","category":"section"},{"location":"usage/#Bottleneck-Types","page":"User Guide","title":"Bottleneck Types","text":"Memory-bound (COMPUTE/MEMORY): Limited by a specific combination of compute throughput and memory bandwidth\nExample: \"Memory-bound (DP/DRAM)\"\nCompute-bound (COMPUTE): Limited by any compute throughput\nExample: \"Compute-bound\"\n\nSelection priority: Memory-bound bottleneck determination uses the highest measured compute type paired with the slowest memory level","category":"section"},{"location":"usage/#Plot-Modes","page":"User Guide","title":"Plot Modes","text":"Simple mode (linear scales):\n\nSingle memory level, or --force-simple flag\nLinear x and y axes\n\nHierarchical mode (log-log scales):\n\nMultiple memory levels\nLog-log scales with ridge points","category":"section"},{"location":"usage/#Plots-Output-Formats","page":"User Guide","title":"Plots Output Formats","text":"Plots can be saved in various formats for easy integration into documents.  \n\nThe format can be selected either by the extension of the filename when --output is selected, or with --plot-format when the automatic naming convention is used.\n\nFormat Options:\n\nPNG\nPDF\nSVG","category":"section"},{"location":"usage/#Examples","page":"User Guide","title":"Examples","text":"# Save plot as PNG (default)\n./roofline.jl --peak-flops-DP=200 --measured-flops-DP=150 \\\n    --peak-bw-DRAM=100 --measured-bw-DRAM=80 \\\n    --output=roofline.png\n\n# Save plot as PDF with the default output naming convention\n./roofline.jl --peak-flops-DP=200 --measured-flops-DP=150 \\\n    --peak-bw-DRAM=100 --measured-bw-DRAM=80 \\\n    --plot-format=pdf\n\n# Save plot as SVG using specified output name\n./roofline.jl --peak-flops-DP=200 --measured-flops-DP=150 \\\n    --peak-bw-DRAM=100 --measured-bw-DRAM=80 \\\n    --output=roofline.svg","category":"section"},{"location":"usage/#Table-Output-Formats","page":"User Guide","title":"Table Output Formats","text":"Several formatting options are available for the analysis tables for easy integration into documents.\n\nFormat Options\n\nascii - Text table (.dat file)\nmarkdown - Markdown (.md file)\norg - Org-mode table (.org file)\ncsv - Comma-separated values (.csv file)","category":"section"},{"location":"usage/#Examples-2","page":"User Guide","title":"Examples","text":"# Print markdown table to console\n./roofline.jl --peak-flops-DP=200 --measured-flops-DP=150 \\\n    --peak-bw-DRAM=100 --measured-bw-DRAM=80 \\\n    --table-format=markdown\n\n# Save CSV table to file\n./roofline.jl --peak-flops-DP=200 --measured-flops-DP=150 \\\n    --peak-bw-DRAM=100 --measured-bw-DRAM=80 \\\n    --table-format=csv --save-table\n\n# Quiet mode with saved markdown table\n./roofline.jl --peak-flops-DP=200 --measured-flops-DP=150 \\\n    --peak-bw-DRAM=100 --measured-bw-DRAM=80 \\\n    --table-format=markdown --save-table --quiet","category":"section"},{"location":"usage/#Getting-Help","page":"User Guide","title":"Getting Help","text":"# Command line help\n./roofline.jl --help\n\n# Julia documentation\njulia> using RooflinePlots\njulia> ?RooflineParams\njulia> ?create_roofline_plot","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page showcases example Roofline plots generated by RooflinePlots.jl, demonstrating the package's capabilities across different configurations.\n\nAll examples shown here are auto-generated during documentation builds from the integration test suite.","category":"section"},{"location":"examples/#Simple-Configuration","page":"Examples","title":"Simple Configuration","text":"","category":"section"},{"location":"examples/#Single-Memory-Level-with-Single-Compute-Type","page":"Examples","title":"Single Memory Level with Single Compute Type","text":"The most basic roofline configuration with DRAM and Double Precision compute.\n\n(Image: Simple DRAM + DP)\n\nConfiguration:\n\nMemory: DRAM only\nCompute: DP (Double Precision) only\nMode: Simple (linear scales)\n\nPerformance Table:\n\n| Metric                     |                  Value |\n|----------------------------|------------------------|\n| Measured DP Compute        |         1245.2 GFLOP/s |\n| Percentage of Peak DP      |                  57.9% |\n| Measured DRAM Bandwidth    |            180.50 GB/s |\n| Percentage of Peak DRAM BW |                  88.1% |\n| DP/DRAM AI                 |            6.90 FLOP/B |\n| Bottleneck                 | Memory-bound (DP/DRAM) |\n\n\n","category":"section"},{"location":"examples/#Hierarchical-Memory","page":"Examples","title":"Hierarchical Memory","text":"","category":"section"},{"location":"examples/#Two-Level-Memory-Hierarchy-with-Multiple-Compute-Types","page":"Examples","title":"Two-Level Memory Hierarchy with Multiple Compute Types","text":"This example shows L2 cache and DRAM with both DP and SP compute types.\n\n(Image: Hierarchical L2+DRAM with DP+SP)\n\nConfiguration:\n\nMemory: L2 cache, DRAM\nCompute: DP, SP\nMode: Hierarchical (log-log scales)\n\nPerformance Table:\n\n| Metric                     |           Value |\n|----------------------------|-----------------|\n| Measured DP Compute        |   720.0 GFLOP/s |\n| Percentage of Peak DP      |           51.2% |\n| Measured SP Compute        |  1440.0 GFLOP/s |\n| Percentage of Peak SP      |           51.3% |\n| Measured L2 Bandwidth      |     185.00 GB/s |\n| Percentage of Peak L2 BW   |           14.1% |\n| Measured DRAM Bandwidth    |      21.89 GB/s |\n| Percentage of Peak DRAM BW |           22.7% |\n| DP/DRAM AI                 |    32.89 FLOP/B |\n| SP/DRAM AI                 |    65.78 FLOP/B |\n| DP/L2 AI                   |     3.89 FLOP/B |\n| SP/L2 AI                   |     7.78 FLOP/B |\n| Bottleneck                 |   Compute-bound |\n\n\n","category":"section"},{"location":"examples/#Full-Memory-Hierarchy","page":"Examples","title":"Full Memory Hierarchy","text":"Complete cache hierarchy demonstrating L1, L2, L3, and DRAM bandwidth limits.\n\n(Image: Full Hierarchy)\n\nConfiguration:\n\nMemory: L1, L2, L3, DRAM (complete hierarchy)\nCompute: DP\nMode: Hierarchical (log-log scales)\nShows all cache levels and their bandwidth transitions\n\nPerformance Table:\n\n| Metric                     |           Value |\n|----------------------------|-----------------|\n| Measured DP Compute        |   720.0 GFLOP/s |\n| Percentage of Peak DP      |           51.2% |\n| Measured L1 Bandwidth      |     890.00 GB/s |\n| Percentage of Peak L1 BW   |           27.8% |\n| Measured L2 Bandwidth      |     185.00 GB/s |\n| Percentage of Peak L2 BW   |           14.1% |\n| Measured L3 Bandwidth      |     125.00 GB/s |\n| Percentage of Peak L3 BW   |           26.0% |\n| Measured DRAM Bandwidth    |      21.89 GB/s |\n| Percentage of Peak DRAM BW |           22.7% |\n| DP/DRAM AI                 |    32.89 FLOP/B |\n| DP/L1 AI                   |     0.81 FLOP/B |\n| DP/L2 AI                   |     3.89 FLOP/B |\n| DP/L3 AI                   |     5.76 FLOP/B |\n| Bottleneck                 |   Compute-bound |\n\n\n","category":"section"},{"location":"examples/#Combined-Measurements","page":"Examples","title":"Combined Measurements","text":"","category":"section"},{"location":"examples/#Combined-DPSP-Measurement","page":"Examples","title":"Combined DP+SP Measurement","text":"Hardware counters often measure multiple compute types together. This example shows how to handle combined measurements.\n\n(Image: Combined DP+SP)\n\nConfiguration:\n\nMemory: L2 cache, DRAM\nCompute: DP and SP roofs (both with same combined measurement)\nMeasurement: Single hardware counter value for both DP and SP\n\nPerformance Table:\n\n| Metric                     |           Value |\n|----------------------------|-----------------|\n| Measured DP+SP Compute     |   720.0 GFLOP/s |\n| Percentage of Peak DP      |           51.2% |\n| Percentage of Peak SP      |           25.6% |\n| Measured L2 Bandwidth      |     185.00 GB/s |\n| Percentage of Peak L2 BW   |           14.1% |\n| Measured DRAM Bandwidth    |      21.89 GB/s |\n| Percentage of Peak DRAM BW |           22.7% |\n| DP+SP/DRAM AI              |    32.89 FLOP/B |\n| DP+SP/L2 AI                |     3.89 FLOP/B |\n| Bottleneck                 |   Compute-bound |\n\n\n","category":"section"},{"location":"examples/#Custom-Type-Names","page":"Examples","title":"Custom Type Names","text":"","category":"section"},{"location":"examples/#HBM-and-Tensor-Cores","page":"Examples","title":"HBM and Tensor Cores","text":"Modern accelerators with High Bandwidth Memory and specialized compute units.\n\n(Image: Custom HBM+TENSOR)\n\nConfiguration:\n\nMemory: HBM (High Bandwidth Memory), L2 cache\nCompute: TENSOR cores, FP32\nDemonstrates support for arbitrary custom type names\n\nPerformance Table:\n\n| Metric                    |                         Value |\n|---------------------------|-------------------------------|\n| Measured FP32 Compute     |                2100.0 GFLOP/s |\n| Percentage of Peak FP32   |                         84.0% |\n| Measured TENSOR Compute   |                4200.0 GFLOP/s |\n| Percentage of Peak TENSOR |                         84.0% |\n| Measured L2 Bandwidth     |                  2800.00 GB/s |\n| Percentage of Peak L2 BW  |                         87.5% |\n| Measured HBM Bandwidth    |                   950.00 GB/s |\n| Percentage of Peak HBM BW |                         79.2% |\n| FP32/HBM AI               |                   2.21 FLOP/B |\n| TENSOR/HBM AI             |                   4.42 FLOP/B |\n| FP32/L2 AI                |                   0.75 FLOP/B |\n| TENSOR/L2 AI              |                   1.50 FLOP/B |\n| Bottleneck                | Memory-bound (FP32+TENSOR/L2) |\n\n\n","category":"section"},{"location":"examples/#Custom-Types-with-Combined-Groups","page":"Examples","title":"Custom Types with Combined Groups","text":"Quantized inference workload with INT8, INT16 combined, and FP32 separate.\n\n(Image: Custom Combined Groups)\n\nConfiguration:\n\nMemory: DDR5\nCompute: INT8, INT16 (measured together), FP32 (measured separately)\nDemonstrates selective grouping of measurements\n\nPerformance Table:\n\n| Metric                      |                    Value |\n|-----------------------------|--------------------------|\n| Measured FP32 Compute       |           3500.0 GFLOP/s |\n| Percentage of Peak FP32     |                    87.5% |\n| Measured INT8+INT16 Compute |           7200.0 GFLOP/s |\n| Percentage of Peak INT8     |                    60.0% |\n| Percentage of Peak INT16    |                    90.0% |\n| Measured DDR5 Bandwidth     |              350.00 GB/s |\n| Percentage of Peak DDR5 BW  |                    87.5% |\n| FP32/DDR5 AI                |             10.00 FLOP/B |\n| INT8+INT16/DDR5 AI          |             20.57 FLOP/B |\n| Bottleneck                  | Memory-bound (INT8/DDR5) |\n\n\n","category":"section"},{"location":"examples/#Custom-Colors","page":"Examples","title":"Custom Colors","text":"Using custom user defined colors\n\n(Image: Custom Colors)\n\nConfiguration:\n\nMemory: DRAM, L3\nCompute: DP, SP \nMemory Colors: \"#3498DB\",\"#2ECC71\"\nCompute Colors = orange,purple \n\n","category":"section"},{"location":"examples/#Generating-Your-Own-Examples","page":"Examples","title":"Generating Your Own Examples","text":"To generate these examples yourself:\n\n# Run integration tests (generates examples)\njulia --project=. test/run_integration_tests.jl\n\n# Clean up generated files\njulia --project=. test/run_integration_tests.jl clean\n\nAll example files are located in test/examples/:\n\nPNG files for plots\nMarkdown files for performance tables\nREADME.md describing each example","category":"section"},{"location":"examples/#Understanding-the-Plots","page":"Examples","title":"Understanding the Plots","text":"","category":"section"},{"location":"examples/#Plot-Elements","page":"Examples","title":"Plot Elements","text":"Diagonal lines: Memory bandwidth limits (different colors for each memory level)\nHorizontal lines: Compute performance ceilings (different colors for each compute type)\nRidge points: Intersections showing transitions between memory-bound and compute-bound regions\nMeasurement points: Your application's actual performance\nCircle markers: Individual measurements\nTriangle/Square markers: Combined measurements","category":"section"},{"location":"examples/#Modes","page":"Examples","title":"Modes","text":"Simple Mode (linear scales):\n\nActivated for single memory level\nClear arithmetic intensity reading on x-axis\nBest for basic analysis\n\nHierarchical Mode (log-log scales):\n\nActivated for multiple memory levels\nShows full memory hierarchy effects\nRidge points clearly visible\nBest for analyzing cache effects","category":"section"},{"location":"examples/#Bottleneck-Identification","page":"Examples","title":"Bottleneck Identification","text":"The plots help identify whether your application is:\n\nMemory-bound: Performance limited by data transfer speeds (below ridge point)\nCompute-bound: Performance limited by computational throughput (above ridge point)\n\nSee the User Guide for detailed explanations and the API Reference for programmatic usage.","category":"section"},{"location":"python/#Python-Interface-Guide","page":"Python Interface Guide","title":"Python Interface Guide","text":"This guide explains how to use RooflinePlots.jl from Python via JuliaCall.","category":"section"},{"location":"python/#Overview","page":"Python Interface Guide","title":"Overview","text":"The Python interface provides a clean, Pythonic API for creating Roofline plots without the raw Julia interop.","category":"section"},{"location":"python/#Quick-Start","page":"Python Interface Guide","title":"Quick Start","text":"from extensions.python.python_utils import RooflinePlotter\n\nplotter = RooflinePlotter()\n\nplotter.create_plot(\n    memory={\"DRAM\": (204.8, 180.5)},      # (peak GB/s, measured GB/s)\n    compute={\"DP\": (2150.4, 1245.2)},     # (peak GFLOP/s, measured GFLOP/s)\n    num_cores=64,\n    cpu_name=\"AMD EPYC 7713\",\n    app_name=\"My Application\"\n).save(\"roofline.png\").print_table()","category":"section"},{"location":"python/#Installation","page":"Python Interface Guide","title":"Installation","text":"pip install juliacall\n\nJuliaCall will automatically download and manage Julia if needed.","category":"section"},{"location":"python/#Python-Utilities","page":"Python Interface Guide","title":"Python Utilities","text":"","category":"section"},{"location":"python/#python_utils.py","page":"Python Interface Guide","title":"python_utils.py","text":"Provides the RooflinePlotter class - a Pythonic wrapper around RooflinePlots.jl:\n\nMain Methods:\n\ncreate_plot(...) - Create a Roofline plot with Python dictionaries\nsave(filename) - Save plot to file\nprint_table() - Print performance analysis table\nget_bottleneck() - Get bottleneck analysis string\n\nConvenience Function:\n\ncreate_simple_plot(...) - Quick function for simple single-level plots","category":"section"},{"location":"python/#Examples","page":"Python Interface Guide","title":"Examples","text":"The examples/ directory contains standalone Python scripts demonstrating different use cases:\n\nsimple_example.py\nBasic single-level Roofline (DRAM + DP)\nPerfect for getting started\nhierarchical_example.py\nFull memory hierarchy (L1, L2, L3, DRAM)\nMultiple compute types (DP, SP)\nDemonstrates hierarchical mode\ncombined_measurement_example.py\nCombined DP+SP measurements\nFor when hardware counters measure multiple types together\ngpu_example.py\nGPU/accelerator configuration\nCustom hardware types (HBM, Tensor cores)","category":"section"},{"location":"python/#Running-Examples","page":"Python Interface Guide","title":"Running Examples","text":"# From repository root\npython extensions/python/examples/simple_example.py\npython extensions/python/examples/hierarchical_example.py\npython extensions/python/examples/combined_measurement_example.py\npython extensions/python/examples/gpu_example.py\n\nEach example is self-contained and generates a Roofline plot with performance analysis.","category":"section"},{"location":"python/#Testing","page":"Python Interface Guide","title":"Testing","text":"Python interface tests are located in test/test_python_interface.py. These tests validate the utility functions work correctly:\n\npython test/test_python_interface.py","category":"section"},{"location":"python/#Raw-Julia-Interop-(Advanced)","page":"Python Interface Guide","title":"Raw Julia Interop (Advanced)","text":"For advanced users who want to extend the functionality, it is possible to sidestep the provided python_utils.py and directly call Julia functions.\n\nfrom juliacall import Main as jl\n\njl.seval(\"using RooflinePlots\")\nmemory_specs = jl.seval('Dict(\"DRAM\" => (peak=204.8, measured=180.5))')\ncompute_specs = jl.seval('Dict(\"DP\" => (peak=2150.4, measured=1245.2))')\nparams = jl.RooflineParams(memory_specs, compute_specs, None, [], 64, \"Dual Socket\", \"AMD EPYC 7713\", \"My App\")\nconfig = jl.params_to_config(params)\nplt = jl.create_roofline_plot(config)\njl.savefig(plt, \"roofline.png\")","category":"section"},{"location":"python/#Common-Troubleshooting","page":"Python Interface Guide","title":"Common Troubleshooting","text":"Module not found error:\n\n# Add to PYTHONPATH from repository root:\nexport PYTHONPATH=\"${PYTHONPATH}:$(pwd)\"\n\nJulia version issues:\n\n# JuliaCall manages Julia automatically\n# To reset the environment:\nrm -rf ~/.julia/juliaup\n\nDisplay issues:\n\n# Ensure Plots backend is set\nfrom juliacall import Main as jl\njl.seval(\"using Plots; gr()\")","category":"section"},{"location":"#RooflinePlots.jl","page":"Home","title":"RooflinePlots.jl","text":"A Julia package for generating Roofline Model visualizations and performance analysis.","category":"section"},{"location":"#About-this-package","page":"Home","title":"About this package","text":"The Roofline Model visualizes performance limits based on computational throughput (FLOP/s) and memory bandwidth (GB/s), helping identify whether applications are compute-bound or memory-bound.\n\nRooflinePlots.jl generates roofline plots and performance analysis for CPU, GPU, and accelerator workloads. It provides both command-line and programmatic interfaces for creating visualizations from hardware performance measurements.\n\nThe motivation for this project came from trying to collect and compare performance metrics from various tools such as likwid and PAPI, and present them in a uniform manner in reports, documentation and publications.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"#Generic-Type-System","page":"Home","title":"Generic Type System","text":"Define arbitrary memory and compute types that match your hardware:\n\nMemory types: DRAM, HBM, DDR5, L1, L2, L3, or custom names\nCompute types: DP, SP, FP16, TENSOR, AVX512, INT8, or custom names\n\nThe package automatically orders and labels performance lines based on specifications.","category":"section"},{"location":"#Hierarchical-Memory-Analysis","page":"Home","title":"Hierarchical Memory Analysis","text":"Visualize full memory hierarchies (L1/L2/L3/DRAM) with automatic log-log scaling when multiple memory levels are specified. Simple mode with linear scaling is used for single-level analysis.","category":"section"},{"location":"#Combined-Measurements","page":"Home","title":"Combined Measurements","text":"Handle hardware counters that measure multiple compute types together (e.g., DP+SP, FP32+TENSOR), reflecting real measurement constraints.","category":"section"},{"location":"#Performance-Analysis","page":"Home","title":"Performance Analysis","text":"Automatic bottleneck detection (memory-bound vs compute-bound)\nPerformance tables showing efficiency percentages\nArithmetic intensity calculations\nMultiple output formats (ASCII, Markdown, Org-mode, CSV)","category":"section"},{"location":"#Flexible-Interfaces","page":"Home","title":"Flexible Interfaces","text":"Command-line interface for quick analysis\nJulia API for programmatic use\nPython interface via JuliaCall","category":"section"},{"location":"#Customization","page":"Home","title":"Customization","text":"Custom color palettes for memory and compute lines\nRidge point visualization control\nForce linear or log-log scaling\nConfigurable output formats","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"./roofline.jl \\\n    --peak-bw-DRAM=204.8 \\\n    --measured-bw-DRAM=180.5 \\\n    --peak-flops-DP=2150.4 \\\n    --measured-flops-DP=1245.2 \\\n    --cpu-name=\"AMD EPYC 7713\" \\\n    --app-name=\"My Application\"\n\nThis generates a roofline plot showing performance limits, measured performance points, and bottleneck analysis.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#From-GitHub","page":"Home","title":"From GitHub","text":"using Pkg\nPkg.add(url=\"https://github.com/qiUip/RooflinePlots.jl.git\")","category":"section"},{"location":"#Development","page":"Home","title":"Development","text":"git clone https://github.com/qiUip/RooflinePlots.jl.git\ncd RooflinePlots.jl\njulia --project=. -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"User Guide - Command-line and Julia API usage with examples\nPython Integration - Using RooflinePlots.jl from Python\nExamples - Gallery of plots for different configurations\nAPI Reference - Complete function and type documentation\nTesting Guide - Running and writing tests","category":"section"},{"location":"#Project-Status","page":"Home","title":"Project Status","text":"This package is under active development. The API is subject to change before the 1.0 release.\n\nCompatibility: Julia 1.6+","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the MIT License - see the LICENSE file for details.","category":"section"},{"location":"examples/simple_dram_dp/","page":"-","title":"-","text":"Metric Value\nMeasured DP Compute 1245.2 GFLOP/s\nPercentage of Peak DP 57.9%\nMeasured DRAM Bandwidth 180.50 GB/s\nPercentage of Peak DRAM BW 88.1%\nDP/DRAM AI 6.90 FLOP/B\nBottleneck Memory-bound (DP/DRAM)","category":"section"}]
}
