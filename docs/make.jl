using Documenter
using RooflinePlots

# Check if we should skip example generation (for faster PR builds)
skip_examples = get(ENV, "SKIP_EXAMPLES", "false") == "true"

if skip_examples
    println("⏩ Skipping example generation (PR build)")

    # Create a placeholder examples.md to avoid broken links
    examples_md_path = joinpath(@__DIR__, "src", "examples.md")
    open(examples_md_path, "w") do io
        write(
            io,
            """
# Examples

Example plots and performance tables are generated on the main branch for deployment.

For pull requests, example generation is skipped to speed up CI builds.

To see the full examples locally, run:
```bash
julia --project=docs docs/make.jl
```

Or view the deployed documentation at [https://qiUip.github.io/RooflinePlots.jl/](https://qiUip.github.io/RooflinePlots.jl/).
""",
        )
    end
else
    using Test

    # Generate examples before building docs
    # This ensures examples are always up-to-date with current code
    println("Generating examples for documentation...")
    test_examples_dir = joinpath(@__DIR__, "..", "test", "examples")
    mkpath(test_examples_dir)

    # Run integration tests to generate examples
    include(joinpath(@__DIR__, "..", "test", "test_integration.jl"))

    # Copy examples into docs/src/examples/ so Documenter can access them
    docs_examples_dir = joinpath(@__DIR__, "src", "examples")
    mkpath(docs_examples_dir)
    for file in readdir(test_examples_dir)
        if endswith(file, ".svg") || endswith(file, ".md")
            cp(
                joinpath(test_examples_dir, file),
                joinpath(docs_examples_dir, file),
                force = true,
            )
        end
    end

    # Generate examples.md with embedded tables
    println("Generating examples.md with performance tables...")
    examples_md_path = joinpath(@__DIR__, "src", "examples.md")
    open(examples_md_path, "w") do io
        write(
            io,
            """
    # Examples

    This page showcases example Roofline plots generated by RooflinePlots.jl, demonstrating the package's capabilities across different configurations.

    All examples shown here are auto-generated during documentation builds from the integration test suite.

    ## Simple Configuration

    ### Single Memory Level with Single Compute Type

    The most basic roofline configuration with DRAM and Double Precision compute.

    ![Simple DRAM + DP](examples/simple_dram_dp.svg)

    **Configuration:**
    - Memory: DRAM only
    - Compute: DP (Double Precision) only
    - Mode: Simple (linear scales)

    **Performance Table:**

    """,
        )

        # Include the table
        table_file = joinpath(docs_examples_dir, "simple_dram_dp.md")
        if isfile(table_file)
            write(io, "```\n")
            write(io, read(table_file, String))
            write(io, "\n```\n\n")
        end

        write(
            io,
            """
    ---

    ## Hierarchical Memory

    ### Two-Level Memory Hierarchy with Multiple Compute Types

    This example shows L2 cache and DRAM with both DP and SP compute types.

    ![Hierarchical L2+DRAM with DP+SP](examples/hierarchical_l2_dram_dp_sp.svg)

    **Configuration:**
    - Memory: L2 cache, DRAM
    - Compute: DP, SP
    - Mode: Hierarchical (log-log scales)

    **Performance Table:**

    """,
        )

        table_file = joinpath(docs_examples_dir, "hierarchical_l2_dram_dp_sp.md")
        if isfile(table_file)
            write(io, "```\n")
            write(io, read(table_file, String))
            write(io, "\n```\n\n")
        end

        write(
            io,
            """
    ---

    ### Full Memory Hierarchy

    Complete cache hierarchy demonstrating L1, L2, L3, and DRAM bandwidth limits.

    ![Full Hierarchy](examples/full_hierarchy.svg)

    **Configuration:**
    - Memory: L1, L2, L3, DRAM (complete hierarchy)
    - Compute: DP
    - Mode: Hierarchical (log-log scales)
    - Shows all cache levels and their bandwidth transitions

    **Performance Table:**

    """,
        )

        table_file = joinpath(docs_examples_dir, "full_hierarchy.md")
        if isfile(table_file)
            write(io, "```\n")
            write(io, read(table_file, String))
            write(io, "\n```\n\n")
        end

        write(
            io,
            """
    ---

    ## Combined Measurements

    ### Combined DP+SP Measurement

    Hardware counters often measure multiple compute types together. This example shows how to handle combined measurements.

    ![Combined DP+SP](examples/combined_dp_sp.svg)

    **Configuration:**
    - Memory: L2 cache, DRAM
    - Compute: DP and SP roofs (both with same combined measurement)
    - Measurement: Single hardware counter value for both DP and SP

    **Performance Table:**

    """,
        )

        table_file = joinpath(docs_examples_dir, "combined_dp_sp.md")
        if isfile(table_file)
            write(io, "```\n")
            write(io, read(table_file, String))
            write(io, "\n```\n\n")
        end

        write(
            io,
            """
    ---

    ## Custom Type Names

    ### HBM and Tensor Cores

    Modern accelerators with High Bandwidth Memory and specialized compute units.

    ![Custom HBM+TENSOR](examples/custom_hbm_tensor.svg)

    **Configuration:**
    - Memory: HBM (High Bandwidth Memory), L2 cache
    - Compute: TENSOR cores, FP32
    - Demonstrates support for arbitrary custom type names

    **Performance Table:**

    """,
        )

        table_file = joinpath(docs_examples_dir, "custom_hbm_tensor.md")
        if isfile(table_file)
            write(io, "```\n")
            write(io, read(table_file, String))
            write(io, "\n```\n\n")
        end

        write(
            io,
            """
    ---

    ### Custom Types with Combined Groups

    Quantized inference workload with INT8, INT16 combined, and FP32 separate.

    ![Custom Combined Groups](examples/custom_combined_groups.svg)

    **Configuration:**
    - Memory: DDR5
    - Compute: INT8, INT16 (measured together), FP32 (measured separately)
    - Demonstrates selective grouping of measurements

    **Performance Table:**

    """,
        )

        table_file = joinpath(docs_examples_dir, "custom_combined_groups.md")
        if isfile(table_file)
            write(io, "```\n")
            write(io, read(table_file, String))
            write(io, "\n```\n\n")
        end

        write(
            io,
            """
    ---

    ### Custom Colors

    Using custom user defined colors

    ![Custom Colors](examples/custom_colors_example.svg)

    **Configuration:**
    - Memory: DRAM, L3
    - Compute: DP, SP 
    - Memory Colors: "#3498DB","#2ECC71"
    - Compute Colors = orange,purple 

    ---

    ## Generating Your Own Examples

    To generate these examples yourself:

    ```bash
    # Run integration tests (generates examples)
    julia --project=. test/run_integration_tests.jl

    # Clean up generated files
    julia --project=. test/run_integration_tests.jl clean
    ```

    All example files are located in `test/examples/`:
    - PNG files for plots
    - Markdown files for performance tables
    - README.md describing each example

    ## Understanding the Plots

    ### Plot Elements

    - **Diagonal lines**: Memory bandwidth limits (different colors for each memory level)
    - **Horizontal lines**: Compute performance ceilings (different colors for each compute type)
    - **Ridge points**: Intersections showing transitions between memory-bound and compute-bound regions
    - **Measurement points**: Your application's actual performance
      - Circle markers: Individual measurements
      - Triangle/Square markers: Combined measurements

    ### Modes

    **Simple Mode** (linear scales):
    - Activated for single memory level
    - Clear arithmetic intensity reading on x-axis
    - Best for basic analysis

    **Hierarchical Mode** (log-log scales):
    - Activated for multiple memory levels
    - Shows full memory hierarchy effects
    - Ridge points clearly visible
    - Best for analyzing cache effects

    ### Bottleneck Identification

    The plots help identify whether your application is:
    - **Memory-bound**: Performance limited by data transfer speeds (below ridge point)
    - **Compute-bound**: Performance limited by computational throughput (above ridge point)

    See the [User Guide](usage.md) for detailed explanations and the [API Reference](api.md) for programmatic usage.
    """,
        )
    end

    println("✓ Examples generated and examples.md created with embedded tables")
end

# Build page list - examples.md is always created (placeholder or full)
pages = [
    "Home" => "index.md",
    "User Guide" => "usage.md",
    "Python Interface Guide" => "python.md",
    "Examples" => "examples.md",
    "API Reference" => "api.md",
    "Testing" => "testing.md",
]

makedocs(;
    modules = [RooflinePlots],
    sitename = "RooflinePlots.jl",
    format = Documenter.HTML(;
        prettyurls = get(ENV, "CI", "false") == "true",
        canonical = "https://qiUip.github.io/RooflinePlots.jl",
        assets = String[],
        analytics = "",
    ),
    pages = pages,
    repo = "https://github.com/qiUip/RooflinePlots.jl/blob/{commit}{path}#{line}",
)

deploydocs(;
    repo = "github.com/qiUip/RooflinePlots.jl.git",
    devbranch = "main",
    push_preview = false,
    forcepush = false,
)
